---
layout: post
title: Pathfinding Woes
date: 2018-02-03
categories: math graph pathfinding complexity big-O
---
## Pathfinding across the graph

My first assumption was that I'm going to have to implement a pathfinding algorithm to guide my river claims.  This was based on my [previous discource](/icfp/ai/algorithms/strategy/2018/01/27/punter-strategies.html) on punter strategies. My thinking was that we pick a target and claim our way towards it.  On further reflection I've come up with some issues. The first is that building such a path map is an O(n^3) operation.  All well and good on the smaller mapps, but absolutely debilitating on maps like Edinburgh and Oxford (n ~ 7000).  In addition, I then have got to thinking about what happens when another punter claims a river - do I need to re-compute the path lengths again, every turn.  Well, yes probably I do if I'm going down that track.  Given that there are time limits to each punter's turn, that might be a bit of a problem on large maps. (Note: given that I have perfect hindsight after the contest, I know they didn't run with the mega maps, but I wouldn't have known that at the time, and hey I'd like to see how my punters go against the winners on untried maps as well).

So I'll start with an approach that does build a path map for every node, probably using Dijkstra, and I'll benchmark that.  As far as dynamic updates, we'll just have to see.  My theory is, you don't need to update every turn, as _assuming_ you're up against rational players, they are focussed on building paths away from their mines, and mines are not _usually_ clumped together.  Plus in a map of x,000 rivers, each turn only will take away <<1% of available paths, and these should not be close to where you are (unless you're building claims off a mine shared with another punter..but that's for another day).  I was thinking of partitioning the graph based on the x.y metadata - but it's totally possible that it's not going to be available in the 'production' map dealt out by the server, so it's probably not a good idea.  It would however help with designing a heuristic for A* - because I'm at a bit of a loss at the moment on how to generate a heuristic other than h(x) = 1 (or at least n/big number).  A glance at the real maps has not really shown any clumping of node ids against (x,y) co-ords, although that will need some more vigorous analysis because any optimisation will help. If I can find that 1 is always connected to 2 and in the vicinity of 3,4,5, etc, then that will make things easier.  If they've been really tricky and randomly allocated ids (ie 1 connects to 432 which connects to 32 ..) then no heuristic will help me there.  It's not like the typical use case for A* where you can use some derivative or dead reckoning on a cartesian plane to make your heuristic, ie H(x) = DR(x,y). Mind you, I'm only about 40% of the way through my first Graph Theory book, so I'll probably find out more in due course. 

### The Alternative

Perhaps I don't actually need to do pathfinding at all, and certainly not across the whole graph. Obviously for maximum score, you only want to claim rivers that will add to the score, so Shortest Path will be the most economical use of your claims, but really the thing we want to most avoid is loop-like or snaking paths with unclaimed shortcuts back to the mine.  Maybe a short-term look-forward to the next X nodes (say X=n/(punters*100 - ie 1% of my calimable space) would be sufficient. This will be an area for investigation of time performance (ie avoiding 'passing a turn') and optimal score. Again, I can look to see which size graphs to optimise for, but indeed even without a priori knowledge of what they actually ran in the contest, I would tend to assume that the mega-maps would be used less frequently, and probably only at later stages of the competition, than the smaller/easier maps. And while large maps will naturally score higher, the winner is the team with the most wins, not the most points, so it's possible to be sub-optimal on mega-maps as long as you're very good on smaller ones.  And of course there's no reason the punter can't switch the mechanism based on map size once the game starts, after all. 

### Connecting Mines

Where the above comes unstuck a little, is the strategy of connecting 2 mines together to double-up scores.  I really don't know how likely that sort of strategy is to be successful, but if I'm going to go down that path, then making a quick bee-line between the mines will require a SP algorithm.

### Extra complications

Just this week I've discovered that they threw in some extension rules as well, including one where a river can be claimed twice (options), one where you can pass your next M moves and then get M+1 (splurges) and one which is pure gambling (futures).  I don't like my chances on futures (I'm not a gambler in real life), but splurges offers a way of getting free compute time if needed, and options can reduce the amount of path re-calc (and invalidate some strategies like choke points). In theory, with splurges, passing every other turn gives you a 50% (3 for the price of 2) increase in river acquisition - probably not an early game strategy, but potentially useful in mid-late game scenarios.

### Lots of theory, but...

Not much implementation this week.  Real work (ie stuff I get paid for) and some health issues have severly impacted on my play time, even today (Saturday). However, I've got a graph data structure up and running last week, still have to tweak it a little bit, and I've got the basis for my algorithms to work on.  Test coverage is very good at 97% (the only bits missing are catch-all exceptions which I'm finding hard to generate in the test cases - eg if a file exists, and is readable, (ie those exceptions are handled) I can't at the moment thing of another way to trigger some sort of unexpected Error.  That aside, I've quite enjoyed the TDD approach to writing the tests first, and it will be interesting writing up the tests for the path algorithms - I wonder if tests will actually help me find a heuristic for A* - it should certainly show up if the heuristic is inadmissable as the path may not be the shortest one, but if there's a way of doing some sort of monte-carlo in pytest with multiple parameters (gee sounds like genetic algorithms there) eg starting at 1, then 2, .. to sqrt(n) or something like that, we I could get an insight into what works reliably across different graphs/maps.

My TODO list is growing faster than I am coding. Doing something like this in 3 days would be immense, means you have to know the problem domain pretty well at the outset - you can't be looking up cs.stackexchange.com continually.  But I don't think the contest is designed for people like me who need to learn the theory as they go along. 

When I last did this back in 2008, at least I knew a little bit of the problem domain, but back then I decided that I definitely should learn a new programming language while implementing.  Turns out picking up Scheme was not that straightforward (even for a Ruby-proficient), even if it is supposed to be a more approachable Lisp.  So for the next one, I should at least be proficient in Python for the implementation; and in trees and graphs, and algorithms for pathfinding and scheduling for the theory/approach.  And of course ICFP'18 will probably require none of that theory ;-p  But knowledge is never wasted - and I think trees are always in high demand.

### Tomorrow

Hopefully tomorrow I'll find out how long it actually takes to calculate all the shortest paths on a mega-map.  Maybe I'm worrying about nothing...
